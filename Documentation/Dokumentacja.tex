\documentclass[]{report}
\usepackage[utf8]{inputenc}
\usepackage{polski}
\usepackage[T1]{fontenc}
\usepackage[utf8]{inputenc}
\usepackage{listings}
\usepackage{xcolor}



\lstdefinestyle{mystyle}{
	language=C++,
	basicstyle=\footnotesize\ttfamily,
	keywordstyle=\color{blue},
	commentstyle=\color{green!60!black},
	identifierstyle=\color{black},
	stringstyle=\color{orange},
	numbers=left,
	numberstyle=\tiny\color{gray},
	breaklines=true,
	showstringspaces=false,
	backgroundcolor=\color{black!5},
	frame=single,
	rulecolor=\color{black!30},
	linewidth=\linewidth,
	xleftmargin=0.00\linewidth,
	xrightmargin=0.00\linewidth,
}

\lstset{style=mystyle,tabsize=2}

% Title Page
\title{Szachy}
\author{Szymon Makulec Jan Moskal}


\begin{document}
\maketitle
\section*{Cel i efekty pracy}


\subsection*{Opis}
\begin{flushleft}
Projekt zakładał stworzenie gry w szachy dla dwóch graczy. Kod oparty jest na bibliotece wxWidgets, a interfejs użytkownika wykorzystuje siatkę wxBitmapButton z obrazkami figur połączonymi z kolorem tła, do reprezentacji szachownicy i figur na niej położonych. Projekt udało nam się doprowadzić do stanu gdzie są przestrzegane zasady gry w szachy takie jak: ruszanie się na zmianę graczy, figury mają tylko takie możliwości ruchy jakby była to normalna gra, mamy dostęp do roszady, pierwszego ruchu piona o 2, promocji piona. Przestrzegane są również zasady związane z szachowaniem tj. nie możemy się ruszyć w taki sposób by po ruchu król był dalej pod biciem.
\end{flushleft}
\subsection*{Tablice obiektów}

\textbf{Użycie obrazków (images[2][13])}

\begin{lstlisting}
// Black Pieces Images
images[0][0] = wxBitmap(wxImage("images/D.jpg"));
images[0][1] = wxBitmap(wxImage(_T("images/Pieces/bpB.png")));
images[0][2] = wxBitmap(wxImage(_T("images/Pieces/bpD.png")));
images[0][3] = wxBitmap(wxImage(_T("images/Pieces/brB.png")));
images[0][4] = wxBitmap(wxImage(_T("images/Pieces/brD.png")));
images[0][5] = wxBitmap(wxImage(_T("images/Pieces/bnB.png")));
images[0][6] = wxBitmap(wxImage(_T("images/Pieces/bnD.png")));
images[0][7] = wxBitmap(wxImage(_T("images/Pieces/bbB.png")));
images[0][8] = wxBitmap(wxImage(_T("images/Pieces/bbD.png")));
images[0][9] = wxBitmap(wxImage(_T("images/Pieces/bqB.png")));
images[0][10] = wxBitmap(wxImage(_T("images/Pieces/bqD.png")));
images[0][11] = wxBitmap(wxImage(_T("images/Pieces/bkB.png")));
images[0][12] = wxBitmap(wxImage(_T("images/Pieces/bkD.png")));

// White Pieces Images
images[1][0] = wxBitmap(wxImage("images/B.jpg"));
images[1][1] = wxBitmap(wxImage(_T("images/Pieces/wpB.png")));
images[1][2] = wxBitmap(wxImage(_T("images/Pieces/wpD.png")));
images[1][3] = wxBitmap(wxImage(_T("images/Pieces/wrB.png")));
images[1][4] = wxBitmap(wxImage(_T("images/Pieces/wrD.png")));
images[1][5] = wxBitmap(wxImage(_T("images/Pieces/wnB.png")));
images[1][6] = wxBitmap(wxImage(_T("images/Pieces/wnD.png")));
images[1][7] = wxBitmap(wxImage(_T("images/Pieces/wbB.png")));
images[1][8] = wxBitmap(wxImage(_T("images/Pieces/wbD.png")));
images[1][9] = wxBitmap(wxImage(_T("images/Pieces/wqB.png")));
images[1][10] = wxBitmap(wxImage(_T("images/Pieces/wqD.png")));
images[1][11] = wxBitmap(wxImage(_T("images/Pieces/wkB.png")));
images[1][12] = wxBitmap(wxImage(_T("images/Pieces/wkD.png")));
\end{lstlisting}
\vspace{\baselineskip}
Do wyświetlania figur na przyciskach wxBitmapButton, używamy zestawu dwudziestu sześciu obrazków, reprezentujących figury szachowe. Dwa puste pola (czarne i białe) oraz sześć różnych typów figur (pion, wieża, skoczek, goniec, hetman, król) w dwóch kolorach (biały i czarny) na dwóch tłach (jasnym, ciemnym). images, jest to tablica, w której przechowywane są obrazy figur szachowych używane do wyświetlania na przyciskach wxBitmapButton na szachownicy. Umożliwia łatwe zarządzanie obrazkami figur szachowych w grze.

\begin{flushleft}
\textbf{Użycie przycisków wxBitmapButton (board[8][8])}
\end{flushleft}
\begin{lstlisting}
board[0][0] = BitmapButton1;
board[0][1] = new wxBitmapButton(this, wxNewId(), images[0][6], wxDefaultPosition, wxDefaultSize, wxBU_AUTODRAW, wxDefaultValidator);
board[0][2] = new wxBitmapButton(this, wxNewId(), images[0][7], wxDefaultPosition, wxDefaultSize, wxBU_AUTODRAW, wxDefaultValidator);
board[0][3] = new wxBitmapButton(this, wxNewId(), images[0][10], wxDefaultPosition, wxDefaultSize, wxBU_AUTODRAW, wxDefaultValidator);
board[0][4] = new wxBitmapButton(this, wxNewId(), images[0][11], wxDefaultPosition, wxDefaultSize, wxBU_AUTODRAW, wxDefaultValidator);
board[0][5] = new wxBitmapButton(this, wxNewId(), images[0][8], wxDefaultPosition, wxDefaultSize, wxBU_AUTODRAW, wxDefaultValidator);
board[0][6] = new wxBitmapButton(this, wxNewId(), images[0][5], wxDefaultPosition, wxDefaultSize, wxBU_AUTODRAW, wxDefaultValidator);
board[0][7] = new wxBitmapButton(this, wxNewId(), images[0][4], wxDefaultPosition, wxDefaultSize, wxBU_AUTODRAW, wxDefaultValidator);

for(int j = 0; j < 8; j++){
	if(j%2 == 0){
		board[1][j] = new wxBitmapButton(this, wxNewId(),images[0][2] , wxDefaultPosition, wxDefaultSize, wxBU_AUTODRAW, wxDefaultValidator);
	}else{
		board[1][j] = new wxBitmapButton(this, wxNewId(),images[0][1] , wxDefaultPosition, wxDefaultSize, wxBU_AUTODRAW, wxDefaultValidator);
		
	}
}

for(int i = 2; i < 6; i++){
	for(int j = 0; j < 8; j++){
		if((i+j)%2 == 0){
			board[i][j] = new wxBitmapButton(this, wxNewId(), images[1][0], wxDefaultPosition, wxDefaultSize, wxBU_AUTODRAW, wxDefaultValidator);
		}else{
			board[i][j] = new wxBitmapButton(this, wxNewId(), images[0][0], wxDefaultPosition, wxDefaultSize, wxBU_AUTODRAW, wxDefaultValidator);
		}
	}
}

for(int j = 0; j < 8; j++){
	if((j)%2 != 0){
		board[6][j] = new wxBitmapButton(this, wxNewId(), images[1][2], wxDefaultPosition, wxDefaultSize, wxBU_AUTODRAW, wxDefaultValidator);
	}else{
		board[6][j] = new wxBitmapButton(this, wxNewId(), images[1][1], wxDefaultPosition, wxDefaultSize, wxBU_AUTODRAW, wxDefaultValidator);
		
	}
}

board[7][0] = new wxBitmapButton(this, wxNewId(), images[1][4], wxDefaultPosition, wxDefaultSize, wxBU_AUTODRAW, wxDefaultValidator);
board[7][1] = new wxBitmapButton(this, wxNewId(), images[1][5], wxDefaultPosition, wxDefaultSize, wxBU_AUTODRAW, wxDefaultValidator);
board[7][2] = new wxBitmapButton(this, wxNewId(), images[1][8], wxDefaultPosition, wxDefaultSize, wxBU_AUTODRAW, wxDefaultValidator);
board[7][3] = new wxBitmapButton(this, wxNewId(), images[1][9], wxDefaultPosition, wxDefaultSize, wxBU_AUTODRAW, wxDefaultValidator);
board[7][4] = new wxBitmapButton(this, wxNewId(), images[1][12], wxDefaultPosition, wxDefaultSize, wxBU_AUTODRAW, wxDefaultValidator);
board[7][5] = new wxBitmapButton(this, wxNewId(), images[1][7], wxDefaultPosition, wxDefaultSize, wxBU_AUTODRAW, wxDefaultValidator);
board[7][6] = new wxBitmapButton(this, wxNewId(), images[1][6], wxDefaultPosition, wxDefaultSize, wxBU_AUTODRAW, wxDefaultValidator);
board[7][7] = new wxBitmapButton(this, wxNewId(), images[1][3], wxDefaultPosition, wxDefaultSize, wxBU_AUTODRAW, wxDefaultValidator);

for(int i = 0;i < 8; i++){
	for(int j = 0; j < 8; j++){
		if(i + j == 0){
			j++;
		}
		GridSizer1->Add(board[i][j], 1, wxALIGN_CENTER_HORIZONTAL|wxALIGN_CENTER_VERTICAL, 5);
		Connect(board[i][j]->GetId(),wxEVT_COMMAND_BUTTON_CLICKED,(wxObjectEventFunction)&Chess2DDialog::OnBitmapButton1Click);
		
		
	}
}
\end{lstlisting}
\vspace{\baselineskip}
Każdy element board[i][j] (8x8) reprezentuje jedno pole z wyświetloną figurą danego koloru i tłem na szachownicy, zawiera przycisk do interakcji z użytkownikiem. Każdy przycisk jest obsługiwany przez tą samą funkcję OnBitmapButton1Click.

\begin{flushleft}
\textbf{Użycie figur (pieces[2][7])}
\end{flushleft}
\begin{lstlisting}
pieces[0][0] = new Pawn(false);
pieces[0][1] = new Rook(false);
pieces[0][2] = new Knight(false);
pieces[0][3] = new Bishop(false);
pieces[0][4] = new Queen(false);
pieces[0][5] = new King(false);
pieces[0][6] = new Rook(false);
pieces[1][0] = new Pawn(true);
pieces[1][1] = new Rook(true);
pieces[1][2] = new Knight(true);
pieces[1][3] = new Bishop(true);
pieces[1][4] = new Queen(true);
pieces[1][5] = new King(true);
pieces[1][6] = new Rook(true);
\end{lstlisting}
\vspace{\baselineskip}
\textbf{pieces[i][j]} jest to dwuwymiarowa tablica wskaźników do obiektów klasy Piece. Jest to tablica, w której przechowywane są obiekty reprezentujące różne typy figur szachowych w dwóch kolorach: białym i czarnym. Każdy obiekt klasy Piece przechowuje informacje o tym czy figura już się ruszała. Dlatego tworzymy dwie wieże, żeby każdej z osobna można było sprawdzać czy się ruszała. W przypadku pionów uznaliśmy tworze oddzielnych Pawnów za zbyteczne, ponieważ każdy może poruszać się tylko w 1 kierunku.
\begin{flushleft}
\textbf{Przechowywanie przycisków i figur w jednym obiekcie (squares[8][8])}
\end{flushleft}
\begin{lstlisting}
for(int i = 0; i < 8; i++){
	for(int j = 0; j < 8; j++){
		if((i+j) % 2 == 0){
			squares[i][j] = new Square(i, j , true, board[i][j]);
		}else{
			squares[i][j] = new Square(i, j , false, board[i][j]);
		}
	}
}

for(int i = 0; i < 8; i++){
	squares[1][i]->setPiece(pieces[0][0]);
	squares[6][i]->setPiece(pieces[1][0]);
}

// Assigning other Pieces to Squares
squares[0][0]->setPiece(pieces[0][1]);
squares[0][1]->setPiece(pieces[0][2]);
squares[0][2]->setPiece(pieces[0][3]);
squares[0][3]->setPiece(pieces[0][4]);
squares[0][4]->setPiece(pieces[0][5]);
squares[0][5]->setPiece(pieces[0][3]);
squares[0][6]->setPiece(pieces[0][2]);
squares[0][7]->setPiece(pieces[0][6]);
squares[7][0]->setPiece(pieces[1][1]);
squares[7][1]->setPiece(pieces[1][2]);
squares[7][2]->setPiece(pieces[1][3]);
squares[7][3]->setPiece(pieces[1][4]);
squares[7][4]->setPiece(pieces[1][5]);
squares[7][5]->setPiece(pieces[1][3]);
squares[7][6]->setPiece(pieces[1][2]);
squares[7][7]->setPiece(pieces[1][6]);
\end{lstlisting}
\begin{flushleft}
\textbf{squares[i][j]} to dwuwymiarowa tablica wskaźników do obiektów typu Square, reprezentująca pola szachownicy. Każdy element tej tablicy to obiekt Square, który przechowuje informacje o polu (przycisk, figura oraz wiersz, kolumna i kolor pola).
\end{flushleft}
\section*{Struktura klas}

Projekt składa się z kilku klas, które są ze sobą powiązane w celu zorganizowania logiki gry w szachy. Poniżej przedstawiona jest struktura klas, ich relacje oraz krótkie opisy.\vspace{\baselineskip}

\textbf{Chess2DDialog}: Główna klasa projektu, dziedzicząca po wxDialog, reprezentująca okno gry w szachy. Odpowiada za obsługę interfejsu użytkownika i inicjalizację gry.\vspace{\baselineskip}

\textbf{Board}: Klasa reprezentująca szachownicę. Odpowiada za logikę gry, przechowuje obiekty klasy Square reprezentujące pola na szachownicy.\vspace{\baselineskip}

\textbf{Square}: Klasa reprezentująca pole na szachownicy. Zawiera informacje o kolorze pola, wierszu i kolumnie pola oraz referencje do przycisku wxBitmapButton i do figury Piece.\vspace{\baselineskip}

\textbf{Piece}: Klasa abstrakcyjna, po niej dziedziczą konkretne rodzaje figur szachowych. Zawiera podstawowe metody i pola, takie jak: kolor, czy to czy figura się ruszała. Wprowadza metode wirtualną dotyczącą zwracania typu figury.\vspace{\baselineskip}

\textbf{Pawn, Rook, Knight, Bishop, Queen, King}: Klasy dziedziczące po klasie Piece, reprezentujące poszczególne rodzaje figur szachowych. Każda z tych klas implementuje pola z informacjami na temat danej figury.

\subsection*{Relacje między klasami:}

\textbf{Chess2DDialog} zawiera obiekt klasy \textbf{Board}, który odpowiada za logikę gry i przechowuje informacje o szachownicy.\vspace{\baselineskip}

Klasa \textbf{Board} zarządza tablicą obiektów \textbf{Square} reprezentujących pola na szachownicy.\vspace{\baselineskip}

Każdy obiekt \textbf{Square} zawiera referencję do obiektu wxBitmapButton oraz informacje o obecności figury (\textbf{Piece}).\vspace{\baselineskip}

Klasy \textbf{Pawn, Rook, Knight, Bishop, Queen, King} dziedziczą po klasie \textbf{Piece} i zawierają specyficzne implementacje metod związanych z ich ruchami.
\begin{flushleft}
Ta struktura klas pozwala na uporządkowanie kodu i łatwość rozbudowy gry.
\end{flushleft}
\section*{Szczegóły konkretnych klas:}

\subsection*{Chess2DDialog}

\begin{lstlisting}
wxBitmapButton* board[8][8];
wxBitmap images[2][13];

int counter = 1;
int whiteOrBlack = 1;

_B = new Board(1);

\end{lstlisting}
\begin{flushleft}
W konstruktorze klasy tworzony jest obiekt klasy Board, który będzie reprezentować szachownicę w grze. Tutaj są wczytywane obrazki do images[2][13] oraz tworzone przyciski umieszczane w board[8][8], a także liczniki odpowiadające za liczenie kliknięć i pilnowanie czyj mamy ruch. Zawiera również obsługę zdarzeń związanych z interakcją użytkownika (OnBitmapButtonClick()). Także w tym miejscu jest kod odpowiedzialny za wyświetlanie szachownicy.
\end{flushleft}
\subsection*{Board}

\begin{lstlisting}
class Board
{
	public:
	Board(int i);
	~Board();
	void cleaning();
	void creatingSquares();
	void creatingPieces();
	void assigningPieces();
	void restart();
	void setClicked(int _nrBB);
	void setDestination(int _nrBB);
	bool isClickedPiece();
	bool isDestinationPiece();
	bool arePiecesSameColor();
	bool isGoodColorMoving();
	void updateSquares(Square* _clicked, Square* _destination);
	bool isKingInside();
	void wasKingMoving();
	int whereIsKing();
	bool castling();
	bool pawnBlockedByPieceInFront();
	void pawnMovesButNothingIsInFront();
	void pawnTakes();
	void pawnPromotion();
	void whereICanMove(Square* clicked);
	bool isInSetOfMoves();
	bool isSomethingBetween(Square* _squareOne, Square* _squareTwo, int _typeInt);
	bool isBeatable(Square* _square);
	bool moveSimulation(Square* clicked, Square* destination);
	bool isMate();
	Piece* pieces[2][7];
	Square* squares[8][8];
	Square* clicked;
	Square* destination;
	Square* whiteKing;
	Square* blackKing;
	Square* squareBetween;
	Square* target;
	set<int> setOfMoves;
	list<int> listOfThreats;
	list<int> listOfDefenders;
	list<int> listOfHope;
	list<int> listOfInsanity;
};

\end{lstlisting}
\begin{flushleft}
Klasa Board jest centralnym punktem logiki gry, zarządzającym szachownicą. Zawiera tablicę obiektów Square oraz tablicę obiektów Piece. Jest w niej kod odpowiedzialny za ustawienie początkowego rozmieszczenia figur na szachownicy. Klasa Board implementuje logikę ruchu figur, sprawdzając, czy dany ruch jest zgodny z zasadami gry w szachy. Odpowiada za obsługę zdarzeń związanych z interakcją użytkownika na poziomie szachownicy, takich jak kliknięcia na pola. Po wykonaniu ruchu odpowiednio aktualizuje widok.
\end{flushleft}
\subsection*{Square}

\begin{lstlisting}
class Square
{
	public:
	friend class Board;
	Square(int _row, int _col, bool _backgroundColor, wxBitmapButton* _button, Piece* _piece = nullptr);
	~Square();
	int getRow();
	int getCol();
	bool getBackgroundColor();
	wxBitmapButton* getButton();
	Piece* getPiece();
	void setPiece(Piece* _piece);
	
	protected:
	int row;
	int col;
	bool backgroundColor;
	wxBitmapButton* button;
	Piece* piece;
};
\end{lstlisting}
\begin{flushleft}
Klasa Square reprezentuje pojedyncze pole na szachownicy. Przechowuje informację o kolorze pola na szachownicy (jasne/ciemne), wierszu i kolumnie pola. Zawiera referencję do obiektu klasy Piece reprezentującego figurę. Jeśli pole jest puste, wartość ta to nullptr. Przechowuje referencję do przycisku, który jest powiązany z danym polem na szachownicy.
\end{flushleft}
\subsection*{Piece}

\begin{lstlisting}
class Piece
{
	public:
	Piece(bool _color, bool _moved);
	virtual ~Piece();
	bool getColor();
	bool getMoved();
	void setMoved();
	virtual int getTypeInt()=0;
	
	protected:
	bool color;
	bool moved;
};
\end{lstlisting}
\vspace{\baselineskip}
Klasa Piece stanowi abstrakcję dla poszczególnych rodzajów figur (piona, wieży, skoczka, gońca, hetmana, króla). Klasa posiada konstruktor, który inicjuje kolor figury oraz informację o tym, czy figura wykonała ruch. Posiada metode virtual int getTypeInt()=0: Jest to metoda czysto wirtualna, zwracająca typ figury jako wartość liczbową (przydatna do indeksach naszych tablic).

\subsection*{Pawn, Rook, Knight, Bishop, Queen, King}

\begin{lstlisting}
class Pawn:public Piece
{
	public:
	Pawn(bool _color, bool _moved = false);
	~Pawn();
	int getTypeInt();
	
	private:
	int TypeInt = 1;
};
\end{lstlisting}
\vspace{\baselineskip}
Klasy te dziedziczą po klasie Piece i reprezentują konkretne figury w grze. Poniżej przedstawiono kluczowe elementy tech klas: Posiada informację o tym, czy figura wykonała swój pierwszy ruch w grze. To istotne np. dla reguły pierwszego ruchu piona lub dla roszady Posiada informację (int) o typie konkretnej figury. Wszytskie te klasy są identyczne.

\subsection*{Metody w klasie Board:}

\textbf{Odpowiedzialne za restartowanie gry oraz usuwanie i tworzenie obiektów:}

\begin{lstlisting}
void cleaning();
void creatingSquares();
void creatingPieces();
void assigningPieces();
void restart();
\end{lstlisting}
\begin{flushleft}
$\bullet$ \textbf{cleaning()}: Usuwa zmienne tworzone dynamicznie (korzysta z niej destruktor i restart).

$\bullet$ \textbf{creatingSquares()}: Tworzy obiekty reprezentujące pola na szachownicy.

$\bullet$ \textbf{creatingPieces()}: Tworzy obiekty reprezentujące figury szachowe.

$\bullet$ \textbf{assigningPieces()}: Przypisuje figury do odpowiednich pól na szachownicy (pozycje startowe).

$\bullet$ \textbf{restart()}: Przywraca początkowe ustawienie figur na szachownicy.

\textbf{Odpowiedzialne za obsługę interakcji użytkownika z szachownicą, kontrolujące kliknięcia, aby zapobiec nieoczekiwanym i niechcianym zachowaniom:}
\end{flushleft}
\begin{lstlisting}
void setClicked(int _nrBB);
void setDestination(int _nrBB);
bool isClickedPiece();
bool isDestinationPiece();
bool arePiecesSameColor();
bool isGoodColorMoving();
\end{lstlisting}
\begin{flushleft}
$\bullet$ \textbf{setClicked(int \_nrBB)}: ustawia kliknięte pole


$\bullet$ \textbf{setDestination(int \_nrBB)}: ustawia docelowe pole

$\bullet$ \textbf{isClickedPiece()}: sprawdza czy w klikniętym polu jest jakaś figura (używana po to żeby sprawdzić czy w wybranym polu jest jakaś figura, którą można się ruszyć)

$\bullet$ \textbf{isDestinationPiece()}: sprawdza czy w docelowym polu jest jakaś figura

$\bullet$ \textbf{arePiecesSameColor()}: sprawdza czy w klikniętym i docelowym polu są figury tego samego koloru (używana żeby zapobiec ruszaniu się na pola gdzie mamy własne figury)

$\bullet$ \textbf{isGoodColorMoving()}: sprawdza czy ruch wykonuje kolor, którego jest teraz kolej

 \textbf{Odpowiedzialna za aktualizacje szachownicy po ruchu:}

\begin{lstlisting}
void updateSquares(Square* _clicked, Square* _destination);
\end{lstlisting}
$\bullet$ \textbf{updateSquares(Square* \_clicked, Square* \_destination)}: ustawia obrazki i figury na polu klikniętym i docelowym

 \textbf{Odpowiedzialne za lokalizację oraz zmianę pozycji króli królów:}

\begin{lstlisting}
bool isKingInside();
void wasKingMoving();
int whereIsKing();
\end{lstlisting}
$\bullet$ \textbf{isKingInside()}: sprawdza czy król jest w klikniętym polu

$\bullet$ \textbf{wasKingMoving()}: sprawdza na koniec ruchu czy król się ruszył i aktualizuje jego lokalizacje

$\bullet$ \textbf{whereIsKing()}: zwraca pozycje króla strony, która jest teraz na ruchu

\textbf{Odpowiedzialna za roszadę}

\begin{lstlisting}
bool castling();
\end{lstlisting}
$\bullet$ \textbf{castling()}: sprawdza czy w danym ruchu roszada miała miejsce, jeśli nie miała lub się udała to zwraca false, jeśli nie można było jej zrobić zwraca true

\textbf{Odpowiedzialne za ruch i bicie (przez niego) piona oraz jego promocje:}

\begin{lstlisting}
bool pawnBlockedByPieceInFront();
void pawnMovesButNothingIsInFront();
void pawnTakes();
void pawnPromotion();
\end{lstlisting}

$\bullet$ \textbf{pawnBlockedByPieceInFront()}: sprawdza czy ruch pion jest blokowany przez figury przed nim

$\bullet$ \textbf{pawnMovesButNothingIsInFront()}: wykonuje ruch piona, gdy nic przed nim nie stoi

$\bullet$ \textbf{pawnTakes()}: wykonuje bicie po przekątnej gdy są tam jakieś figury przeciwnika

$\bullet$ \textbf{pawnPromotion()}: sprawdza czy pion znajduje się w pierwszym rzędzie u przeciwnika wtedy zamienia go w hetmana

 \textbf{Odpowiedzialne za sprawdzanie legalnych ruchów dla każdej figury:}

\begin{lstlisting}
void whereICanMove();
bool isInSetOfMoves();
bool isSomethingBetween(Square* _squareOne, Square* _squareTwo, int _typeInt);
\end{lstlisting}

$\bullet$ \textbf{whereICanMove()}: tworzy zbiór legalnych ruchów dla figury wybranej przez gracza

$\bullet$ \textbf{isInSetOfMoves()}: sprawdza czy ruch wybrany przez gracza jest w zbiorze legalnych ruchów dla danej figury

$\bullet$ \textbf{isSomethingBetween(Square* \_squareOne, Square* \_squareTwo, int \_typeInt)}: sprawdza czy między dwoma polami jest jakaś figura (używane do sprawdzenia czy nic nie stoi na drodze na dane pole)

 \textbf{Odpowiedzialne za szachowanie i symulacje ruchów}

\begin{lstlisting}
bool isBeatable(Square* _square);
bool moveSimulation();
\end{lstlisting}

$\bullet$ \textbf{isBeatable(Square* \_square)}: sprawdza czy wybrana figura jest podbiciem przez jakąś figure (używane głównie do sprawdzania szachowania króla)

$\bullet$ \textbf{moveSimulation()}: przeprowadza symulacje ruchu (potem cofa wprowadzone zmiany) w sytuacji gdy król jest pod szachem, jeśli ruch gracza sprawia, że król nie jest już pod szachem zwraca true, w przeciwnym wypadku false

\subsection*{Przeprowadzenie przez rozgrywkę}
\textbf{Obsługa przycisków (OnBitmapButton1Click)}
\begin{lstlisting}
void Chess2DDialog::OnBitmapButton1Click(wxCommandEvent& event){
	int nrBB = event.GetId() - 100;
	
	if(counter%2 != 0){
		_B->setClicked(nrBB);
		if(!(_B->isClickedPiece()) || !(_B->isGoodColorMoving())){
			return;
		}
		counter++;
		return;
	}
	
	if(counter%2 == 0){
		_B->setDestination(nrBB);
		if(_B->isDestinationPiece() && _B->arePiecesSameColor()){
			counter--;
			return;
		}
		_B->whereICanMove();
		
		if(!_B->isInSetOfMoves()){
			counter--;
			return;
		}
		if(_B->isSomethingBetween(_B->clicked, _B->destination, _B->clicked->getPiece()->getTypeInt())){
			counter--;
			return;
		}

		if(_B->moveSimulation()){
			wxLogMessage("Tutaj nie wolno");
			counter--;
			return;
		}

		if(_B->castling()){
			counter--;
			return;
		}
		_B->updateSquares(_B->clicked, _B->destination);
		
		_B->pawnPromotion();
		_B->wasKingMoving();
		
		whiteOrBlack = (whiteOrBlack + 1)%2;
		
		if( _B->isMate() == true ){
			wxLogMessage("Mat");
		}
		counter++;
		return;
	}
}
\end{lstlisting}
\vspace{\baselineskip}
Funkcja OnBitmapButton1Click w każdym kliknięciu zapisuje nrBB (czyli numer bitmapy indywidualny dla każdego przycisku) a następnie sprawdza po kolei warunki z taką zasadą, że jeśli coś jest nie tak to wracamy do kliknięcia 1. W kliknięciu 1, poprzez wskaźnik do clicked zapisuje informacje o klikniętym Squarze. Następnie sprawdza po kolei czy na klikniętym polu znajdowała się figura a potem czy ma ona odpowiedni kolor (czyli czy dobra osoba się rusza). Kolejność jest ważna, ponieważ bez sprawdzenia czy na klikniętym polu jest figura mogłoby dojść do sytuacji, że chcemy użyć metody z klasy Piece na polu, w którym Piece-a nie ma i program zakończyłby działanie. Jeśli wszystko się zgadza zwiększamy counter o 1 i wychodzimy z metody. Przy kliknięciu 2 tak jak w 1 przekazujemy wskaźnik tylko tym razem do destination. Sprawdzamy wpierw czy kliknięte miejsce ma figurę a jeśli ma to sprawdzamy czy jest tego samego koloru. Jeśli jednak nie było z tym problemu to do zbioru poprzez funkcje whereICanMove() zapisujemy możliwe ruchy nie uwzględniając tego, że figura może zostać zablokowana. Następnie sprawdzamy czy destination w ogóle zawiera się w naszym zbiorze ruchów. Jeśli tak to następnie sprawdzamy czy jest coś między polem startowym a docelowym a jeśli i to przejdzie bez problemów to wykonywana jest symulacja ruchu, która ma sprawdzić czy po ruchu nasz król nie będzie pod szachem. Pod koniec sprawdzamy czy może ktoś niechciałby zrobić roszady. Uaktualniamy pozycje, sprawdzamy czy na ostatnich liniach nie stoją piony, które chciałyby dostać awans. Jeśli ruszał się król to poprzez metodę wasKingMoving() sprawdzamy jego kolor i w zależności od tego uaktualniamy blackKing lub whiteKing, dzięki którym możemy na bieżąco sprawdzać gdzie znajdują się króle na planszy. Na koniec naszego ruchu sprawdzamy czy nie zmatowaliśmy przeciwnika.
\newpage
\subsection*{Wybrane metody z Board.cpp}
\textbf{updateSquares(Square* \_clicked, Square* \_destination)}

\begin{lstlisting}
void Board::updateSquares(Square* _clicked, Square* _destination){
	this->destination->setPiece(this->clicked->getPiece());
	this->destination->getButton()->SetBitmap(images[this->clicked->getPiece()->getColor()][this->clicked->getPiece()->getTypeInt()+1-this->destination->getBackgroundColor()]);
	this->destination->getPiece()->setMoved();
	this->clicked->setPiece(nullptr);
	this->clicked->getButton()->SetBitmap(images[this->clicked->getBackgroundColor()][0]);
	}
\end{lstlisting}
\vspace{\baselineskip}
Metoda działa w taki sposób, że najpierw w miejscu docelowym ustawiamy jaka figura będzie stać na tym polu, następnie obrazek figury, którą chcemy się ruszyć. Wykorzystujemy tutaj fakt, że w tablicy images[a][b] a odpowiada za kolor figury a b za to jaka to figura oraz czy stoi na polu białym czy czarnym gdzie w naszej tablicy obrazki na biały i czarnym polu znajdują się od siebie w odległości 1. Następnie ustawiamy figurze, że się ruszyła a na koniec usuwamy ślady naszej figury z pola startowego.
\vspace{\baselineskip}
\newline
\textbf{castling()}
\begin{lstlisting}
bool Board::castling(){
	if(this->clicked != this->squares[whereIsKing()/8][whereIsKing()%8]){
		return 0;
	}
	
	if(abs((this->destination->getCol() - this->squares[whereIsKing()/8][whereIsKing()%8]->getCol())) == 2){
		if(this->destination->getCol() == 2){
			if(this->squares[this->destination->getRow()][0]->getPiece() != nullptr && this->squares[this->destination->getRow()][0]->getPiece()->getMoved() == false){
				if(this->isSomethingBetween(this->clicked,this->squares[this->destination->getRow()][0],3 ) == false){
					this->squares[this->destination->getRow()][3]->setPiece(pieces[this->clicked->getPiece()->getColor()][1]);
					if(!(this->isBeatable(this->clicked)) && !(this->isBeatable(this->squares[this->destination->getRow()][3]))){
						this->squares[this->destination->getRow()][3]->setPiece(this->squares[this->destination->getRow()][0]->getPiece());
						this->squares[this->destination->getRow()][3]->getButton()->SetBitmap(images[this->squares[this->destination->getRow()][0]->getPiece()->getColor()][this->squares[this->destination->getRow()][0]->getPiece()->getTypeInt()+1-this->squares[this->destination->getRow()][3]->getBackgroundColor()]);
						this->squares[this->destination->getRow()][3]->getPiece()->setMoved();
						this->squares[this->destination->getRow()][0]->setPiece(nullptr);
						this->squares[this->destination->getRow()][0]->getButton()->SetBitmap(images[this->squares[this->destination->getRow()][0]->getBackgroundColor()][0]);
						return 0;
					}return 1;
					
				}return 1;
				
			}return 1;
			
		}else if(this->destination->getCol() == 6){
			if(this->squares[this->destination->getRow()][7]->getPiece() != nullptr && this->squares[this->destination->getRow()][7]->getPiece()->getMoved() == false){
				if(this->isSomethingBetween(this->clicked,this->squares[this->destination->getRow()][7], 3) == false){
					this->squares[this->destination->getRow()][5]->setPiece(pieces[this->clicked->getPiece()->getColor()][1]);
					if(!(this->isBeatable(this->clicked)) && !(this->isBeatable(this->squares[this->destination->getRow()][5]))){
						this->squares[this->destination->getRow()][5]->setPiece(this->squares[this->destination->getRow()][7]->getPiece());
						this->squares[this->destination->getRow()][5]->getButton()->SetBitmap(images[this->squares[this->destination->getRow()][7]->getPiece()->getColor()][this->squares[this->destination->getRow()][7]->getPiece()->getTypeInt()+1-this->squares[this->destination->getRow()][5]->getBackgroundColor()]);
						this->squares[this->destination->getRow()][5]->getPiece()->setMoved();
						this->squares[this->destination->getRow()][7]->setPiece(nullptr);
						this->squares[this->destination->getRow()][7]->getButton()->SetBitmap(images[this->squares[this->destination->getRow()][7]->getBackgroundColor()][0]);
						return 0;
					}return 1;
					
				}return 1;
				
			}return 1;
			
		}return 1;
	}
	return 0;
}
\end{lstlisting}
\vspace{\baselineskip}
Na początek sprawdzamy czy w ogóle próbowaliśmy ruszyć się królem. Następnie sprawdzamy w warunkach kolejno:
\newline
$\bullet$ Czy pole docelowe znajduje się w odległości 2 od króla - Jest to jedyna taka sytuacja gdy król może poruszyć się o 2 pola\newline
$\bullet$ Czy król próbuje zrobić roszadę długą - Czyli czy kolumna docelowa ma numer 2 ( numerując od 0 )\newline
$\bullet$ Czy po drugiej stronie w ogóle stoi wieża z którą moglibyśmy zrobić roszadę oraz czy dla wieży to będzie pierwszy ruch\newline
$\bullet$ Czy pomiędzy królem a wieżą jest pusta przestrzeń - z pomocą metody isSomethingBetween\newline
Następnie w pole, w którym znajdzie się wieża po roszadzie wpisujemy wieżę by móc dla tego pola wykonać metodę isBeatable
i sprawdzamy czy pola, na których był lub przez, które będzie przechodził król są szachowane. Jeśli wszystko jest jak powinno to następuje roszada. To samo wykonuje się dla roszady krótkiej tyle, że sprawdzamy inne pola.
\vspace{\baselineskip}
\newline
\textbf{isSomethingBetween(Square* \_squareOne, Square* \_squareTwo, int \_typeInt)}

\begin{lstlisting}
bool Board::isSomethingBetween(Square* _squareOne, Square* _squareTwo, int _typeInt){
	listOfDefenders.clear();
	int _col = _squareOne->getCol();
	int _row = _squareOne->getRow();
	int wsp_col = - (_col - _squareTwo->getCol())/abs(_col - _squareTwo->getCol());
	this->squareBetween = squares[this->whereIsKing()/8][this->whereIsKing()%8];
	switch(_typeInt){
		case 1:
		if(abs(_row - _squareTwo->getRow()) == 2 && this->clicked->getPiece()->getColor() == 1){
			if(this->squares[ 5 ][_col]->getPiece() != nullptr){
				return true;
			}
		}
		if(abs(_row - _squareTwo->getRow()) == 2 && this->clicked->getPiece()->getColor() == 0){
			if(this->squares[ 2 ][_col]->getPiece() != nullptr){
				return true;
			}
		}
		return false;
		break;
		case 3:
		if(_col - _squareTwo->getCol() == 0){
			for(int row = _row - (_row - _squareTwo->getRow())/abs(_row - _squareTwo->getRow()); abs(row - _squareTwo->getRow()) >0; row = row - (row - _squareTwo->getRow())/abs(row - _squareTwo->getRow())){
				this->listOfDefenders.push_back(row * 8 + _col);
				if(this->squares[row][_col]->getPiece() != nullptr){
					this->squareBetween = this->squares[row][_col];
					return true;
				}
			}
			return false;
		}
		if(_row - _squareTwo->getRow() == 0){
			for(int col = _col - (_col - _squareTwo->getCol())/abs(_col - _squareTwo->getCol()); abs(col - _squareTwo->getCol()) >0; col = col - (col - _squareTwo->getCol())/abs(col - _squareTwo->getCol())){
				this->listOfDefenders.push_back(_row * 8 + col);
				if(this->squares[_row][col]->getPiece() != nullptr){
					this->squareBetween = this->squares[_row][col];
					return true;
				}
			}
			return false;
		}
		break;
		case 7:
		for(int wsp = _row - (_row - _squareTwo->getRow())/abs(_row - _squareTwo->getRow()); abs(wsp - _squareTwo->getRow()) >0; wsp = wsp - (wsp - _squareTwo->getRow())/abs(wsp - _squareTwo->getRow())){
			this->listOfDefenders.push_back(wsp * 8 + _col + wsp_col);
			if(this->squares[wsp][_col + wsp_col]->getPiece() != nullptr){
				this->squareBetween = this->squares[wsp][_col + wsp_col];
				return true;
			}else{
				_col = wsp_col + _col;
			}
		}
		return false;
		break;
		case 9:
		wsp_col = - (_col - _squareTwo->getCol())/abs(_col - _squareTwo->getCol());
		if(_col - _squareTwo->getCol() == 0){
			for(int row = _row - (_row - _squareTwo->getRow())/abs(_row - _squareTwo->getRow()); abs(row - _squareTwo->getRow()) >0; row = row - (row - _squareTwo->getRow())/abs(row - _squareTwo->getRow())){
				this->listOfDefenders.push_back(row * 8 + _col);
				if(this->squares[row][_col]->getPiece() != nullptr){
					return true;
				}
			}
			return false;
		}
		if(_row - _squareTwo->getRow() == 0){
			for(int col = _col - (_col - _squareTwo->getCol())/abs(_col - _squareTwo->getCol()); abs(col - _squareTwo->getCol()) >0; col = col - (col - _squareTwo->getCol())/abs(col - _squareTwo->getCol())){
				this->listOfDefenders.push_back(_row * 8 + col);
				if(this->squares[_row][col]->getPiece() != nullptr){
					return true;
				}
			}
			return false;
		}
		for(int wsp = _row - (_row - _squareTwo->getRow())/abs(_row - _squareTwo->getRow()); abs(wsp - _squareTwo->getRow()) >0; wsp = wsp - (wsp - _squareTwo->getRow())/abs(wsp - _squareTwo->getRow())){
			this->listOfDefenders.push_back(wsp * 8 + _col + wsp_col);
			if(this->squares[wsp][_col + wsp_col]->getPiece() != nullptr){
				return true;
			}else{
				_col = wsp_col + _col;
			}
		}
		return false;
		break;
		
		default:
		return false;
	}
	return false;
}

\end{lstlisting}
\vspace{\baselineskip}
W tej metodzie robimy wiele rzeczy na raz. Była ona robiona z myślą, żeby sprawdzać czy jak chcemy się gdzieś ruszyć to nie stoi nam coś na drodze jednak potem uznaliśmy, że może nam się przydać żeby sprawdzić czy coś nie atakuje króla. Dlatego w momencie gdy funkcja natknie sie na jakieś pole, to zapisuje je do squareBetween. Zapisuje ona również do listy listOfDefenders wszystkie pola pomiędzy polem startowym a końcowym. Co do działania funkcji to w argumentach przekazujemy jej pole początkowe oraz końcowe oraz jako kto chcemy się poruszyć (jaką figurą). W zależności od naszego \_typeInt wchodzimy do innego case-a w switchu i kolejno dla piona sprawdzamy tylko sytuację gdy może ruszyć się o 2, dla wieży sprawdzamy czy ruch odbywa się na kierunku poziomym czy pionowym a następnie odpowiednio czy góra/prawo czy dół/lewo. Dla gońca sprawdzamy po której przekątnej będziemy sprawdzać na zasadzie +/- 1 na kierunku poziomym i +/- 1 pionowym. Hetman to połączona wieża i goniec. Pozostałe figury nie mają takich ograniczeń.
\vspace{\baselineskip}
\newline
\textbf{isBeatable(Square* \_square)}

\begin{lstlisting}
bool Board::isBeatable(Square* _square){
	this->listOfThreats.clear();
	
	int _Row = _square->getRow();
	int _Col = _square->getCol();
	
	//is Rook checking us
	for(int i = 0; i < 8; i = i+7){
		if(_Row != i && isSomethingBetween(squares[_Row][_Col], squares[i][_Col], 3)){
			if(this->squareBetween->getPiece()->getTypeInt() == 3 || this->squareBetween->getPiece()->getTypeInt() == 9){
				if(this->squares[_Row][_Col]->getPiece()->getColor() != this->squareBetween->getPiece()->getColor()){
					this->listOfThreats.push_back(this->squareBetween->getRow() * 8 + this->squareBetween->getCol());
					
				}
			}
		}else{
			if(_Row != i && this->squares[i][_Col]->getPiece() != nullptr && this->squares[_Row][_Col]->getPiece()->getColor() != this->squares[i][_Col]->getPiece()->getColor()){
				if(this->squares[i][_Col]->getPiece()->getTypeInt() == 9 || this->squares[i][_Col]->getPiece()->getTypeInt() == 3){
					this->listOfThreats.push_back(this->squares[i][_Col]->getRow() * 8 + this->squares[i][_Col]->getCol());
				}
			}
		}
		if(_Col != i && isSomethingBetween(squares[_Row][_Col], squares[_Row][i], 3)){
			if(this->squareBetween->getPiece()->getTypeInt() == 3 || this->squareBetween->getPiece()->getTypeInt() == 9){
				if(this->squares[_Row][_Col]->getPiece()->getColor() != this->squareBetween->getPiece()->getColor()){
					this->listOfThreats.push_back(this->squareBetween->getRow() * 8 + this->squareBetween->getCol());
				}
			}
		}else{
			if(_Col != i && this->squares[_Row][i]->getPiece() != nullptr && this->squares[_Row][_Col]->getPiece()->getColor() != this->squares[_Row][i]->getPiece()->getColor()){
				if(this->squares[_Row][i]->getPiece()->getTypeInt() == 9 || this->squares[_Row][i]->getPiece()->getTypeInt() == 3){
					this->listOfThreats.push_back(this->squares[_Row][i]->getRow() * 8 + this->squares[_Row][i]->getCol());
				}
			}
		}
		
	}
	
	//is Bishop checking us
	for(int i = 1; i < 8; i++){
		if((_Row)- i >=0 && _Col-i >=0){
			if(squares[_Row-i][_Col-i]->getPiece() != nullptr){
				if(this->squares[_Row][_Col]->getPiece()->getColor()!= this->squares[_Row-i][_Col-i]->getPiece()->getColor()){
					if(this->squares[_Row-i][_Col-i]->getPiece()->getTypeInt() == 7 || this->squares[_Row-i][_Col-i]->getPiece()->getTypeInt() == 9){
						this->listOfThreats.push_back(this->squares[_Row - i][_Col - i]->getRow() * 8 + this->squares[_Row - i][_Col - i]->getCol());
						continue;
					}
				}
				i = i+10;
			}
		}
	}
	
	for(int i = 1; i < 8; i++){
		if((_Row)- i >=0 && _Col+i <=7){
			if(squares[_Row-i][_Col+i]->getPiece() != nullptr){
				if(this->squares[_Row][_Col]->getPiece()->getColor()!= this->squares[_Row-i][_Col+i]->getPiece()->getColor()){
					if(this->squares[_Row-i][_Col+i]->getPiece()->getTypeInt() == 7 || this->squares[_Row-i][_Col+i]->getPiece()->getTypeInt() == 9){
						this->listOfThreats.push_back(this->squares[_Row - i][_Col + i]->getRow() * 8 + this->squares[_Row - i][_Col + i]->getCol());
						continue;
					}
				}
				i = i+10;
			}
		}
	}
	
	for(int i = 1; i < 8; i++){
		if((_Row)+ i <=7 && _Col+i <=7){
			if(squares[_Row+i][_Col+i]->getPiece() != nullptr){
				if(this->squares[_Row][_Col]->getPiece()->getColor()!= this->squares[_Row+i][_Col+i]->getPiece()->getColor()){
					if(this->squares[_Row+i][_Col+i]->getPiece()->getTypeInt() == 7 || this->squares[_Row+i][_Col+i]->getPiece()->getTypeInt() == 9){
						this->listOfThreats.push_back(this->squares[_Row + i][_Col + i]->getRow() * 8 + this->squares[_Row + i][_Col + i]->getCol());
						continue;
					}
				}
				i = i+10;
			}
		}
	}
	
	for(int i = 1; i < 8; i++){
		if((_Row)+ i <=7 && _Col-i >=0){
			if(squares[_Row+i][_Col-i]->getPiece() != nullptr){
				if(this->squares[_Row][_Col]->getPiece()->getColor()!= this->squares[_Row+i][_Col-i]->getPiece()->getColor()){
					if(this->squares[_Row+i][_Col-i]->getPiece()->getTypeInt() == 7 || this->squares[_Row+i][_Col-i]->getPiece()->getTypeInt() == 9){
						this->listOfThreats.push_back(this->squares[_Row + i][_Col - i]->getRow() * 8 + this->squares[_Row + i][_Col - i]->getCol());
						continue;
					}
				}
				i = i+10;
			}
		}
	}
	
	//is Pawn checking us
	for(int i = -1; i < 2; i = i + 2){
		if(_Row == 0){
		}else{
			if(_Col - i >= 0 && _Col - i <= 7 && squares[_Row - 1][_Col - i]->getPiece() != nullptr){
				if(this->squares[_Row][_Col]->getPiece()->getColor() != this->squares[_Row - 1][_Col - i]->getPiece()->getColor()){
					if(this->squares[_Row - 1][_Col - i]->getPiece()->getTypeInt() == 1 && this->squares[_Row - 1][_Col - i]->getPiece()->getColor() == 0){
						this->listOfThreats.push_back(this->squares[_Row - 1][_Col - i]->getRow() * 8 + this->squares[_Row - 1][_Col - i]->getCol());
					}
				}
			}
		}
	}
	
	for(int i = -1; i < 2; i = i + 2){
		if(_Row == 7){
		}else{
			if(_Col - i >= 0 && _Col - i <= 7 && squares[_Row + 1][_Col - i]->getPiece() != nullptr){
				if(this->squares[_Row][_Col]->getPiece()->getColor()!= this->squares[_Row + 1][_Col - i]->getPiece()->getColor()){
					if(this->squares[_Row + 1][_Col - i]->getPiece()->getTypeInt() == 1 && this->squares[_Row + 1][_Col - i]->getPiece()->getColor() == 1){
						this->listOfThreats.push_back(this->squares[_Row + 1][_Col - i]->getRow() * 8 + this->squares[_Row + 1][_Col - i]->getCol());
					}
				}
			}
		}
	}
	
	// is Knight checking us
	for(int i = 0; i < 5; i = i+4){
		for(int j = 0; j < 3; j = j+2){
			if(_Row + i  <= 9 && _Row + i >=2 && _Col + j <= 8 && _Col + j >=1 ){
				if(squares[_Row + i - 2][_Col + j - 1]->getPiece() != nullptr){
					if(this->squares[_Row][_Col]->getPiece()->getColor()!= this->squares[_Row + i - 2][_Col + j - 1]->getPiece()->getColor()){
						if(this->squares[_Row + i - 2][_Col + j - 1]->getPiece()->getTypeInt() == 5){
							this->listOfThreats.push_back(this->squares[_Row + i - 2][_Col + j - 1]->getRow() * 8 + this->squares[_Row + i - 2][_Col + j - 1]->getCol());
						}
					}
				}
			}
			if(_Row + j <= 8 && _Row + j >=1 && _Col + i <= 9 && _Col + i >= 2){
				if(squares[_Row + j - 1][_Col + i - 2]->getPiece() != nullptr){
					if(this->squares[_Row][_Col]->getPiece()->getColor()!= this->squares[_Row + j - 1][_Col + i - 2]->getPiece()->getColor()){
						if(this->squares[_Row + j - 1][_Col + i - 2]->getPiece()->getTypeInt() == 5){
							this->listOfThreats.push_back(this->squares[_Row + j - 1][_Col + i - 2]->getRow() * 8 + this->squares[_Row + j - 1][_Col + i - 2]->getCol());
						}
					}
				}
			}
		}
	}
	
	// is King checking us
	if(_square->getPiece()->getColor() == 0){
		if(abs(this->whiteKing->getCol() - _square->getCol())<=1 && abs(this->whiteKing->getRow() - _square->getRow())<=1){
			this->listOfThreats.push_back(this->whiteKing->getRow() * 8 + this->whiteKing->getCol());
		}
	}else{
		if(abs(this->blackKing->getCol() - _square->getCol())<=1 && abs(this->blackKing->getRow() - _square->getRow())<=1){
			this->listOfThreats.push_back(this->blackKing->getRow() * 8 + this->blackKing->getCol());
		}
	}
	if(!this->listOfThreats.empty()){
		return true;
	}
	return false;
}
\end{lstlisting}
\vspace{\baselineskip}
Metoda działa w taki sposób, że dla pola, które chcemy sprawdzić czy jest atakowane wykonuje po kolei oraz w każdym kierunku isSomethingBetween z type intem odpowiednim w zależności od tego czego szukamy np. przed nami w oddali będziemy poszukiwać hetmana lub wieży zaś po skosie będziemy szukać hetmana lub gońca. Każde pole, z którego można zbić wybrane przez nas pole zapisywane jest do listOfThreats. Wiele podobnych rzeczy co w isSomethingBetween więc nie będziemy się nad nimi rozwodzić. 
\vspace{\baselineskip}
\newline
\textbf{moveSimulation(Square* \_clicked, Square* \_destination)}

\begin{lstlisting}
bool Board::moveSimulation(Square* _clicked, Square* _destination){
	bool x = false;
	if((this->blackKing == _clicked) + (this->whiteKing == _clicked) == 1){
		if(_clicked->getPiece()->getColor()){
			this->whiteKing = _destination;
		}else{
			this->blackKing = _destination;
		}
	}
	Square* pieceStorage = new Square(-1, -1, 0, board[0][0], nullptr);
	if(_destination->getPiece() != nullptr){
		pieceStorage->setPiece(_destination->getPiece());
	}
	_destination->setPiece(_clicked->getPiece());
	_clicked->setPiece(nullptr);
	if(this->isBeatable(this->squares[whereIsKing()/8][whereIsKing()%8])){
		x = true;
	}
	_clicked->setPiece(_destination->getPiece());
	if(pieceStorage->getPiece() == nullptr){
		_destination->setPiece(nullptr);
	}else{
		_destination->setPiece(pieceStorage->getPiece());
	}
	if((this->blackKing == _destination) + (this->whiteKing == _destination) == 1){
		if(_clicked->getPiece()->getColor()){
			this->whiteKing = _clicked;
		}else{
			this->blackKing = _clicked;
		}
	}
	delete pieceStorage;
	return x;
}
\end{lstlisting}
\vspace{\baselineskip}
Jest to jedna z najistotniejszych metod naszego programu. Jest to sztuczne wywołanie ruchu, poza wzrokiem gracza. Na początek sprawdzamy czy ruszamy się królem jeśli tak to zmieniamy jego pozycje. Następnie wykonujemy prawie, że zwykły ruch. Prawie, bo nie interesują nas wyświetlane obrazki oraz przechowujemy to pole, do którego ktoś próbuje się ruszyć. Robimy to po to by nie stracić informacji o tym co się w nim znajduje. Po wykonaniu ruchu sprawdzamy czy król jest po nim szachowany i tą informacje zwrócimy na koniec programu. Przed zwróceniem tej informacji wracamy ze wszystkim do pozycji początkowej. Funkcja prosta a jednak jakże przydatna.
\vspace{\baselineskip}
\newline
\newpage
\textbf{isMate()}

\begin{lstlisting}
bool Board::isMate(){
	
	int _col = this->whereIsKing() % 8;
	int _row = this->whereIsKing() / 8;
	this->clicked = this->squares[_row][_col];
	if(!isBeatable(this->squares[_row][_col])){
		return false;
	}
	listOfHope = listOfThreats;
	this->whereICanMove(this->squares[_row][_col]);
	
	for(auto it = this->setOfMoves.begin(); it != this->setOfMoves.end(); ++it){
		this->clicked = this->squares[_row][_col];
		if(abs(_col - *it % 8) == 2){
			continue;
		}
		
		if(this->squares[*it / 8][*it % 8]->getPiece() == nullptr || this->squares[*it / 8][*it % 8]->getPiece()->getColor() != this->squares[_row][_col]->getPiece()->getColor()){
			this->destination = this->squares[*it / 8][*it % 8];
			if(!this->moveSimulation(this->squares[_row][_col], this->squares[*it / 8][*it % 8])){
				return false;
			}
		}
	}
	
	
	
	this->target = squares[*(listOfHope.begin()) / 8][*(listOfHope.begin()) % 8];
	
	
	if(this->isBeatable(this->target)){
		listOfHope = listOfThreats;
		for(auto it = listOfHope.begin(); it != listOfHope.end(); ++it){
			if(!this->moveSimulation(this->squares[*it / 8][*it % 8], this->target)){
				return false;
			}
		}
	}
	
	if(abs(_row - this->target->getRow()) > 1 ||  abs(_col - this->target->getCol()) > 1 ){
		this->isSomethingBetween(this->squares[_row][_col], this->target, this->target->getPiece()->getTypeInt());
		listOfHope = listOfDefenders;
		
		for(auto it = listOfHope.begin(); it != listOfHope.end(); ++it){
			this->squares[*it / 8][*it % 8]->setPiece(pieces[(this->squares[_row][_col]->getPiece()->getColor()+1)%2][1]);
			this->destination = this->squares[*it / 8][*it % 8];
			if(isBeatable(squares[*it / 8][*it % 8])){
				this->squares[*it / 8][*it % 8]->setPiece(nullptr);
				listOfInsanity = listOfThreats;
				this->squares[*it / 8][*it % 8]->setPiece(nullptr);
				
				
				
				if(this->squares[*it / 8][*it % 8]->getRow() == 4 && squares[_row][_col]->getPiece()->getColor() == 1){
					if(this->squares[6][*it % 8]->getPiece() != nullptr && this->squares[6][*it % 8]->getPiece()->getTypeInt() == 1){
						this->clicked = this->squares[6][*it % 8];
						if(!this->moveSimulation(this->squares[6][*it % 8], this->squares[4][*it % 8])){
							return false;
						}
					}
				}
				if(this->squares[*it / 8][*it % 8]->getRow() == 3 && squares[_row][_col]->getPiece()->getColor() == 0){
					if(this->squares[1][*it % 8]->getPiece() != nullptr && this->squares[1][*it % 8]->getPiece()->getTypeInt() == 1){
						this->clicked = this->squares[1][*it % 8];
						if(!this->moveSimulation(this->squares[1][*it % 8], this->squares[3][*it % 8])){
							return false;
						}
					}
				}
				
				if(*it / 8 < 6 && this->squares[*it / 8 + 1][*it % 8]->getPiece() != nullptr && this->squares[*it / 8 + 1][*it % 8]->getPiece()->getTypeInt() == 1 && this->squares[*it / 8 + 1][*it % 8]->getPiece()->getColor() == 1){
					this->clicked = this->squares[*it / 8 + 1][*it % 8];
					if(!this->moveSimulation(this->squares[*it / 8 + 1][*it % 8], this->squares[*it / 8][*it % 8])){
						return false;
					}
				}
				if(*it / 8 > 1 && this->squares[*it / 8 - 1][*it % 8]->getPiece() != nullptr && this->squares[*it / 8 - 1][*it % 8]->getPiece()->getTypeInt() == 1 && this->squares[*it / 8 - 1][*it % 8]->getPiece()->getColor() == 0){
					this->clicked = this->squares[*it / 8 - 1][*it % 8];
					if(!this->moveSimulation(this->squares[*it / 8 - 1][*it % 8], this->squares[*it / 8][*it % 8])){
						return false;
					}
				}
				
				
				for(auto itt = listOfInsanity.begin(); itt != listOfInsanity.end(); ++itt){
					this->clicked = this->squares[*itt / 8][*itt % 8];
					if(isKingInside()){
						continue;
					}
					if(!this->moveSimulation(this->squares[*itt / 8][*itt % 8], this->squares[*it / 8][*it % 8]) && clicked->getPiece()->getTypeInt() != 1){
						return false;
					}
				}
			}
			
		}
	}
	return true;
}
\end{lstlisting}
\vspace{\baselineskip}
Na sam koniec zrodzony w bólach i mękach mat. Funkcja pobiera od nas lokalizacje króla ( przeciwnego, ponieważ w OnBitmapButtonClicku używamy jej po zwiększeniu licznika whiteOrBlack ). Sprawdzamy czy król jest w ogóle szachowany. Następnie sprawdzamy czy może się gdzieś poruszyć bez bycia dalej szachowanym. Jeśli to nie wyjdzie to ustawiamy nasz cel do zbicia i tworzymy listę figur, które mogłyby ten cel zbić. Gdy taka lista zostanie utworzona to robimy symulację ruchów co by było gdybyśmy tą figurą zbili nasz cel. Robimy to dlatego, że ruch naszej figury może odsłonić króla od innej strony. Jeśli nasz cel jest w odległości jednej kratki od nas, nie możemy się nigdzie ruszyć bez bycia szachowanym oraz nie możemy go zbić to jest to już koniec - mamy mata. W innym przypadku tworzymy listę pól spomiędzy naszego celu i króla a następnie po pętli ustawiamy w niej figurę żeby móc wykonać metodę isBeatable i figury, które mogą wejść w to pole by je zasłonić zapisujemy do listy by i dla nich zrobić symulację ruchu. Jako, że pion jako jedyny ma inne ruszanie się od bicia to dla niego musimy oddzielnie sprawdzić czy może zasłonić. Nie dość, że oddzielnie to jeszcze dla samego piona, oddzielnie dla koloru i dlatego czy możemy się nim ruszyć o 2. Jeśli nic z tych rzeczy nie pomogło to już na pewno mamy mata.
\vspace{\baselineskip}
\newline
\subsection*{Wkład pracy:}
\vspace{\baselineskip}
Robienie projektu odbywało się w większości w taki sposób, że naprzemiennie jedna osoba pisała i cała dwójka myślała. Czasem zdarzało się, że ktoś coś robił "po godzinach".
\vspace{\baselineskip}
\newline
$\bullet$ Tworzenie koncepcji projektu : Jan Moskal - 70\% , Szymon Makulec - 30\%\newline
$\bullet$ Obrabianie obrazków : Jan Moskal - 10\%, Szymon Makulec - 90\%\newline
$\bullet$ Tworzenie szkieletu klas : Jan Moskal - 90\%, Szymon Makulec - 10\%\newline
$\bullet$ Board.cpp oraz Chess2DMain.cpp : Jan Moskal - 25\%, Szymon Makulec - 75\%\newline
$\bullet$ Dokumentacja : Jan Moskal - 45\%, Szymon Makulec - 55\%\newline
$\bullet$ Debugging : Jan Moskal - 50\%, Szymon Makulec - 50\%\newline

\subsection*{Podsumowanie}
Projekt uważamy za udany. Baliśmy się go, często nie wierzyliśmy, że jest szansa na zrobienie go do końca. Nauczył nas wielu przydatnych umiejętności, sprawił, że nasza psychika jest w stanie wytrzymać więcej niż wcześniej. Pomógł zaznajomić się z biblioteką wxWidgets oraz programu zewnętrznego jak github. Jesteśmy świadomi, na ile nasz kod jest niewydajny dlatego w przyszłości planujemy gruntowne zmiany optymalizacyjne.
\end{flushleft}
\end{document}          
